
import { LegalTemplate, TemplateCategory } from '@/types/template';

/**
 * Utility class for loading and managing bulk template data
 * This handles the JSON templates generated by your Python script
 */
export class TemplateLoader {
  private static instance: TemplateLoader;
  private loadedTemplates: Map<string, LegalTemplate> = new Map();
  private categorizedTemplates: Map<string, LegalTemplate[]> = new Map();

  static getInstance(): TemplateLoader {
    if (!TemplateLoader.instance) {
      TemplateLoader.instance = new TemplateLoader();
    }
    return TemplateLoader.instance;
  }

  /**
   * Load templates from JSON files (generated by your Python script)
   * In production, this would load from your server or CDN
   */
  async loadTemplatesFromJSON(jsonTemplates: any[]): Promise<void> {
    try {
      for (const templateData of jsonTemplates) {
        // Validate and transform the template data
        const template: LegalTemplate = {
          id: templateData.id,
          title: templateData.title,
          category: templateData.category.toLowerCase(),
          subcategory: templateData.subcategory || 'general',
          jurisdiction: templateData.jurisdiction || ['India'],
          complexity: this.mapComplexity(templateData.complexity),
          tags: templateData.tags || this.extractTagsFromContent(templateData.content),
          description: templateData.description,
          content: templateData.content,
          placeholders: templateData.placeholders || {},
          metadata: {
            author: templateData.metadata?.author || 'VakilGPT',
            lastUpdated: templateData.metadata?.lastUpdated || new Date().toISOString().split('T')[0],
            version: templateData.metadata?.version || '1.0',
            usage_count: templateData.metadata?.usage_count || 0,
            difficulty: this.mapDifficulty(templateData.complexity),
            estimatedTime: this.estimateCompletionTime(templateData.content),
            requiredFields: Object.keys(templateData.placeholders || {}),
            relatedTemplates: []
          },
          isActive: true,
          isFeatured: templateData.metadata?.usage_count > 50 || false,
          downloadCount: templateData.metadata?.usage_count || 0
        };

        this.loadedTemplates.set(template.id, template);
        this.categorizeTemplate(template);
      }

      console.log(`Loaded ${this.loadedTemplates.size} templates`);
      this.generateRelatedTemplates();
    } catch (error) {
      console.error('Failed to load templates from JSON:', error);
      throw error;
    }
  }

  /**
   * Load templates from a directory of JSON files
   * This simulates loading your 3500+ templates
   */
  async loadTemplatesFromDirectory(templateDirectory: string): Promise<void> {
    try {
      // In a real implementation, this would fetch from your server
      // For now, we'll simulate with a sample load
      const sampleTemplates = await this.loadSampleBulkTemplates();
      await this.loadTemplatesFromJSON(sampleTemplates);
    } catch (error) {
      console.error('Failed to load templates from directory:', error);
      throw error;
    }
  }

  /**
   * Get all loaded templates
   */
  getAllTemplates(): LegalTemplate[] {
    return Array.from(this.loadedTemplates.values());
  }

  /**
   * Get templates by category
   */
  getTemplatesByCategory(category: string): LegalTemplate[] {
    return this.categorizedTemplates.get(category) || [];
  }

  /**
   * Search templates with advanced filtering
   */
  searchTemplates(query: string, filters?: {
    category?: string;
    subcategory?: string;
    complexity?: string;
    jurisdiction?: string[];
    tags?: string[];
  }): LegalTemplate[] {
    let results = Array.from(this.loadedTemplates.values());

    // Apply text search
    if (query) {
      const searchLower = query.toLowerCase();
      results = results.filter(template =>
        template.title.toLowerCase().includes(searchLower) ||
        template.description.toLowerCase().includes(searchLower) ||
        template.content.toLowerCase().includes(searchLower) ||
        template.tags.some(tag => tag.toLowerCase().includes(searchLower))
      );
    }

    // Apply filters
    if (filters) {
      if (filters.category) {
        results = results.filter(t => t.category === filters.category);
      }
      if (filters.subcategory) {
        results = results.filter(t => t.subcategory === filters.subcategory);
      }
      if (filters.complexity) {
        results = results.filter(t => t.complexity === filters.complexity);
      }
      if (filters.jurisdiction) {
        results = results.filter(t => 
          t.jurisdiction.some(j => filters.jurisdiction!.includes(j))
        );
      }
      if (filters.tags && filters.tags.length > 0) {
        results = results.filter(t =>
          filters.tags!.some(tag => t.tags.includes(tag))
        );
      }
    }

    // Sort by relevance and usage
    return results.sort((a, b) => b.metadata.usage_count - a.metadata.usage_count);
  }

  /**
   * Get template statistics
   */
  getTemplateStats(): {
    totalTemplates: number;
    categoryCounts: Record<string, number>;
    complexityCounts: Record<string, number>;
    jurisdictionCounts: Record<string, number>;
  } {
    const templates = this.getAllTemplates();
    
    return {
      totalTemplates: templates.length,
      categoryCounts: this.countByField(templates, 'category'),
      complexityCounts: this.countByField(templates, 'complexity'),
      jurisdictionCounts: this.countByArrayField(templates, 'jurisdiction')
    };
  }

  // Private helper methods
  private mapComplexity(complexity: string): 'basic' | 'intermediate' | 'advanced' {
    const lower = complexity?.toLowerCase();
    if (lower === 'advanced' || lower === 'complex') return 'advanced';
    if (lower === 'intermediate' || lower === 'medium') return 'intermediate';
    return 'basic';
  }

  private mapDifficulty(complexity: string): 'beginner' | 'intermediate' | 'advanced' {
    const lower = complexity?.toLowerCase();
    if (lower === 'advanced' || lower === 'complex') return 'advanced';
    if (lower === 'intermediate' || lower === 'medium') return 'intermediate';
    return 'beginner';
  }

  private extractTagsFromContent(content: string): string[] {
    // Extract common legal terms and keywords from content
    const commonTerms = [
      'agreement', 'contract', 'party', 'clause',
      'terms', 'conditions', 'liability', 'indemnity',
      'breach', 'termination', 'dispute', 'arbitration'
    ];

    const contentLower = content.toLowerCase();
    return commonTerms.filter(term => contentLower.includes(term));
  }

  private estimateCompletionTime(content: string): string {
    const wordCount = content.split(/\s+/).length;
    const placeholderCount = (content.match(/\[[A-Z_]+\]/g) || []).length;
    
    // Estimate based on content length and complexity
    const baseMinutes = Math.ceil(wordCount / 100) + (placeholderCount * 2);
    
    if (baseMinutes <= 5) return '5-10 minutes';
    if (baseMinutes <= 15) return '10-20 minutes';
    if (baseMinutes <= 30) return '20-40 minutes';
    return '40+ minutes';
  }

  private categorizeTemplate(template: LegalTemplate): void {
    if (!this.categorizedTemplates.has(template.category)) {
      this.categorizedTemplates.set(template.category, []);
    }
    this.categorizedTemplates.get(template.category)!.push(template);
  }

  private generateRelatedTemplates(): void {
    // Generate related template suggestions based on category and tags
    this.loadedTemplates.forEach(template => {
      const related = this.findRelatedTemplates(template);
      template.metadata.relatedTemplates = related.slice(0, 5).map(t => t.id);
    });
  }

  private findRelatedTemplates(template: LegalTemplate): LegalTemplate[] {
    return Array.from(this.loadedTemplates.values())
      .filter(t => t.id !== template.id)
      .filter(t => 
        t.category === template.category ||
        t.tags.some(tag => template.tags.includes(tag))
      )
      .sort((a, b) => {
        const aScore = this.calculateSimilarityScore(template, a);
        const bScore = this.calculateSimilarityScore(template, b);
        return bScore - aScore;
      });
  }

  private calculateSimilarityScore(templateA: LegalTemplate, templateB: LegalTemplate): number {
    let score = 0;
    
    // Category match
    if (templateA.category === templateB.category) score += 3;
    
    // Subcategory match
    if (templateA.subcategory === templateB.subcategory) score += 2;
    
    // Tag matches
    const commonTags = templateA.tags.filter(tag => templateB.tags.includes(tag));
    score += commonTags.length;
    
    // Complexity similarity
    if (templateA.complexity === templateB.complexity) score += 1;
    
    return score;
  }

  private countByField(templates: LegalTemplate[], field: keyof LegalTemplate): Record<string, number> {
    return templates.reduce((acc, template) => {
      const value = template[field] as string;
      acc[value] = (acc[value] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
  }

  private countByArrayField(templates: LegalTemplate[], field: keyof LegalTemplate): Record<string, number> {
    return templates.reduce((acc, template) => {
      const values = template[field] as string[];
      values.forEach(value => {
        acc[value] = (acc[value] || 0) + 1;
      });
      return acc;
    }, {} as Record<string, number>);
  }

  private async loadSampleBulkTemplates(): Promise<any[]> {
    // This is where you would load your actual JSON template files
    // For demonstration, returning a sample structure that matches your Python script output
    return [
      {
        id: '550e8400-e29b-41d4-a716-446655440000',
        title: 'Employment Appointment Letter',
        category: 'Employment',
        subcategory: 'General',
        jurisdiction: ['India'],
        complexity: 'basic',
        tags: ['employment', 'appointment', 'job'],
        description: 'Auto-imported template for Employment Appointment Letter.',
        content: 'EMPLOYMENT APPOINTMENT LETTER\n\nDate: [DATE]\n\nDear [EMPLOYEE_NAME],\n\nWe are pleased to inform you that you have been selected for the position of [POSITION] at [COMPANY_NAME]...',
        placeholders: {
          DATE: '',
          EMPLOYEE_NAME: '',
          POSITION: '',
          COMPANY_NAME: '',
          SALARY: '',
          START_DATE: ''
        },
        metadata: {
          author: 'VakilGPT',
          lastUpdated: '2024-01-15',
          version: '1.0',
          usage_count: 12
        }
      }
      // Add more sample templates here...
    ];
  }
}

export const templateLoader = TemplateLoader.getInstance();

/**
 * Hook for using template loader in React components
 */
export const useTemplateLoader = () => {
  const [isLoading, setIsLoading] = React.useState(false);
  const [templates, setTemplates] = React.useState<LegalTemplate[]>([]);
  const [stats, setStats] = React.useState<any>(null);

  const loadTemplates = async (jsonTemplates?: any[]) => {
    setIsLoading(true);
    try {
      if (jsonTemplates) {
        await templateLoader.loadTemplatesFromJSON(jsonTemplates);
      } else {
        await templateLoader.loadTemplatesFromDirectory('/templates');
      }
      
      setTemplates(templateLoader.getAllTemplates());
      setStats(templateLoader.getTemplateStats());
    } catch (error) {
      console.error('Failed to load templates:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  return {
    loadTemplates,
    searchTemplates: templateLoader.searchTemplates.bind(templateLoader),
    getTemplatesByCategory: templateLoader.getTemplatesByCategory.bind(templateLoader),
    templates,
    stats,
    isLoading
  };
};
